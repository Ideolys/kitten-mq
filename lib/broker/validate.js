/**
 * inlineTest contains the error messages and the test code.
 * When the validate function are generated by buildValidateFunction, it gives the possibility to inline the test code directly in the validate function (avoiding function calls).
 * I know that V8 can inline small functions himself but It is still a little bit faster to make inline code ourself
 */
const inlineTest = {
  alpha : {
    error   : '${must contains only letters}',
    getTest : function (value) {
      return 'typeof('+value+') === "string" && /^[a-zA-Z]+$/.test('+value+')';
    }
  },

  alphanumeric : {
    error   : '${must contains only letters and numbers}',
    getTest : function (value) {
      return 'typeof('+value+') === "string" && /^[0-9a-zA-Z]+$/.test('+value+')';
    }
  },

  array : {
    error   : '${must be an array}',
    getTest : function (value) {
      return value+' instanceof Array';
    }
  },

  binary : {
    error   : '${must be a binary type}',
    getTest : function (value) {
      return '(typeof('+value+') === "boolean" || '+value+'==="true" || '+value+'==="false" || /^[01]$/.test('+value+'))';
    }
  },

  boolean : {
    error   : '${must be a boolean}',
    getTest : function (value) {
      return 'typeof('+value+') === "boolean"';
    }
  },

  decimal : {
    error   : '${must be a decimal}',
    getTest : function (value) {
      return '(typeof('+value+') === "number" || /^-?[0-9]+(\\.[0-9]+)?$/.test('+value+'))';
    }
  },

  int : {
    error   : '${must be an integer}',
    getTest : function (value) {
      return 'typeof('+value+') === "number" && '+value+' % 1 === 0 && !isNaN('+value+')';
    }
  },

  number : {
    error   : '${must be a number}',
    getTest : function (value) {
      return 'typeof('+value+') === "number" && !isNaN('+value+')';
    },
  },

  numeric : {
    error   : '${must be a numeric value}',
    getTest : function (value) {
      return '/^-?[0-9]+$/.test('+value+')';
    }
  },

  object : {
    error   : '${must be an object}',
    getTest : function (value) {
      return '!('+value+' instanceof Array) && ('+value+' instanceof Object) && (typeof '+value+' !== "function")';
    }
  },

  string : {
    error   : '${must be a string}',
    getTest : function (value) {
      return 'typeof('+value+') === "string"';
    }
  },

  email : {
    error   : '${must be a valid email}',
    getTest : function (value) {
      return '/^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25}/.test(' + value + ')';
    }
  },

  emailList : {
    error   : '${must be a valid email list}',
    getTest : function (value) {
      return '/^([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25}([\\n ]*;[\\n ]*([a-zA-Z0-9_\\-\\.]+)@([a-zA-Z0-9_\\-\\.]+)\\.([a-zA-Z]{2,5}){1,25})*$/.test(' + value + ')';
    }
  },

  notNull : {
    error   : '${must be defined}',
    getTest : function (value) {
      return value + ' != null';
    }
  }

};



/**
 * Validate - "JSON validator"
 */
const validate = {
  types : Object.keys(inlineTest),

  /**
   * isType(value)
   *
   * @param {mixed} "value" : to test
   * @return {boolean} true if the test is valid, false otherwise
   */
  isArray        : new Function('value', 'return (' + inlineTest['array'       ].getTest('value') + ')'),
  isAlpha        : new Function('value', 'return (' + inlineTest['alpha'       ].getTest('value') + ')'),
  isAlphanumeric : new Function('value', 'return (' + inlineTest['alphanumeric'].getTest('value') + ')'),
  isBinary       : new Function('value', 'return (' + inlineTest['binary'      ].getTest('value') + ')'),
  isBoolean      : new Function('value', 'return (' + inlineTest['boolean'     ].getTest('value') + ')'),
  isDecimal      : new Function('value', 'return (' + inlineTest['decimal'     ].getTest('value') + ')'),
  isInt          : new Function('value', 'return (' + inlineTest['int'         ].getTest('value') + ')'),
  isNumber       : new Function('value', 'return (' + inlineTest['number'      ].getTest('value') + ')'),
  isNumeric      : new Function('value', 'return (' + inlineTest['numeric'     ].getTest('value') + ')'),
  isObject       : new Function('value', 'return (' + inlineTest['object'      ].getTest('value') + ')'),
  isString       : new Function('value', 'return (' + inlineTest['string'      ].getTest('value') + ')'),
  isEmail        : new Function('value', 'return (' + inlineTest['email'       ].getTest('value') + ')'),
  isEmailList    : new Function('value', 'return (' + inlineTest['emailList'   ].getTest('value') + ')'),
  isNotNull      : new Function('value', 'return (' + inlineTest['notNull'     ].getTest('value') + ')'),


  /**
   * Get the field name
   * TODO: this current path should be pre-computed in the main descriptor
   *
   * @param {type} path : description
   * @param {String} iterator
   * @return {type}
   */
  getFieldName : function (path, attr, iterator) {
    var _res = '';

    for (var i = 0; i < path.length; i++) {
      var _elem = path[i];
      if (_res === '') {
        if (_elem.type === 'array') {
          _res += _elem.realObjName + '[' + (iterator ? iterator : '') + ']';
        }
        else {
          _res += _elem.realObjName;
        }
      }
      else {
        if (_elem.type === 'object') {
          _res += '['+_elem.realObjName+']';
        }
        else {
          _res += '['+_elem.realObjName+'][]';
        }
      }
    }

    if (path.length) {
      _res += '['+attr+']';
    }
    else {
      _res += attr;
    }
    return _res;
  },

  /**
   * Analyze an object against a descriptor
   * TODO
   */
  buildValidateFunction : function (descriptor) {
    var _that                       = this;
    var _atLeastOneValidateFunction = false;

    var _s = 'var _e = [];\n';
    _s += 'var _q = [];\n';
    _s += 'var _o = [];\n';

    var _path = [{ objName : '', type : 'object' }];

    // For each object in the descriptor, generate the code which will build the JSON
    for (var _objName in descriptor) {

      var _obj         = descriptor[_objName].obj; // object to build
      var _type        = descriptor[_objName].type; // object type
      var _objParent   = descriptor[_objName].objParent; // unique name of the object parent
      var _realObjName = descriptor[_objName].name; // real name of the parent object
      var _keys        = descriptor[_objName].keys;
      // var _arrChild = descriptor[_objName].arrChild; // unique name of all array children

      var _varName       = _objName   + '_obj';
      var _varParentName = _objParent + '_obj';

      // detect nested array in order to close brackets
      if (_path[_path.length - 1].objName===_objParent) {
        _path.push({ objName : _objName, type : _type, realObjName : _realObjName });
      }
      else {
        while (_path.length > 1 && _path[_path.length-1].objName!==_objParent) {
          var _pathObject = _path.pop();
          if (_pathObject.type==='array') {
            _s += '}\n';
            if (_pathObject.objName !== 'main0') {
              _s += '}\n';
            }
          }
        }
        _path.push({ objName : _objName, type : _type, realObjName : _realObjName });
      }

      var _varNameIterator = null;
      // if this is an object
      if (_type === 'object') {
        if (_objName === 'main0') {
          _s += 'var '+_varName+' = data;\n';
        }
        else {
          _s += 'var '+_varName+' = '+ _varParentName+'["'+_realObjName+'"];\n';
        }
      }
      else if (_type === 'array') {
        if (_objName === 'main0') {
          var _varNameArray = _objName+'_arr';
          _s += 'var '+_varNameArray+' = data;\n';
          _varNameIterator = _objName+'_i';
          _s += 'for(var '+_varNameIterator+'=0;'+ _varNameIterator+'<'+_varNameArray+'.length; '+_varNameIterator+'++){\n';
          _s += 'var '+_varName+' = '+ _varNameArray+'['+_varNameIterator+'];\n';
        }
        else {
          _varNameIterator = _objName+'_i';
          _s += ' if (' + _varParentName + '["' + _realObjName + '"]) {';
          _s += ' for(var '+_varNameIterator+'=0;'+ _varNameIterator+'<'+_varParentName+'["'+_realObjName+'"].length; '+_varNameIterator+'++){\n';
          _s += ' var '+_varName+' = '+ _varParentName+'["'+_realObjName+'"]['+_varNameIterator+'];\n';
        }
      }

      _s += 'if (' + _varName;
      if (_objName !== 'main0') {
        _s += ' && _o.indexOf(\'' + _varParentName + '["' + _realObjName + '"]\') === -1';
      }
      _s += ') {\n';
      // Test every attribute of the object
      for (var _attr in _obj) {
        var _testedVariable = _varName+'["'+_attr+'"]';
        var _test           = _obj[_attr];
        var _testType       = _test[0];

        var _code = this.getConditionCode(_testedVariable, _test);
        // Add a condition only if the developer has specified a validator array
        if (_code.testStr) {
          // We do not want to test id keys for insert
          var _isConditionUpdatePrimaryKey = _objName === 'main0' && _type === 'array' && _keys.indexOf(_attr) !== -1;
          if (_isConditionUpdatePrimaryKey) {
            _s += 'if (isUpdate) {';
          }

          _s += 'if(!('+_code.testStr+')){\n';
          var _field = _that.getFieldName(_path.slice(2),_attr, _varNameIterator);
          _field     = _field.replace(_varNameIterator, '" + ' + _varNameIterator + ' + "');
          _s += '  _e.push({"value":'+_testedVariable+', "field":"'+ _field +'", "index":'+_varNameIterator+', "error": "'+_code.errorMessage+'"});\n';
          if (_testType === 'array' || _testType === 'object') {
            _s += `
              _o.push('${ _testedVariable }');
            `;
          }
          _s += '}\n';

          if (_isConditionUpdatePrimaryKey) {
            _s += '}\n';
          }
        }
        if (_code.nbFunctions || _code.formatStr) {
          _s += 'else{\n';
        }
        if (_code.formatStr) {
          _s += _code.formatStr;
        }
        if (_code.nbFunctions) { // TODO improve
          _atLeastOneValidateFunction = true;
          _field = _that.getFieldName(_path.slice(2),_attr, _varNameIterator);
          _field = _field.replace(_varNameIterator, '" + ' + _varNameIterator + ' + "');
          _s += '_q.push({"value": '+_testedVariable+', "fn":"'+_objName+'_'+_attr+'", "field":"'+ _field +'"});\n';
        }
        if (_code.nbFunctions || _code.formatStr) {
          _s += '}\n';
        }
      }
      _s += '}\n';
    }

    // If the are loop which are not closed by a bracket, close them
    while (_path.length > 1) {
      _pathObject = _path.pop();
      if (_pathObject.type === 'array') {
        _s += '}\n';
        if (_pathObject.objName !== 'main0') {
          _s += '}\n';
        }
      }
    }

    if (_atLeastOneValidateFunction) {
      _s += 'var _incomplete = _q.length;\n';
      _s += 'for (var i = 0; i < _q.length; i++) {\n';
      _s += '  var _testedValue = _q[i];\n';
      _s += '  (function(testedValue){\n';
      _s += '    var _fn = validateFn[testedValue.fn];\n';
      _s += '    _fn.call({"value":testedValue.value}, function(message){\n';
      _s += '      if(message){\n';
      _s += '        _e.push({"value":testedValue.value, "field":testedValue.field, "error":message });\n';
      _s += '      }\n';
      _s += '      _incomplete--;\n';
      _s += '      if(_incomplete===0){\n';
      _s += '        callback(_e);\n';
      _s += '      }\n';
      _s += '    });\n';
      _s += '  })(_testedValue);\n';
      _s += '};\n';
    }
    else {
      _s += 'if(callback){ return callback(_e); };\n';
    }
    _s += ' return _e;\n';

    // The function is built, we compile it and check errors in the same time
    var _fn;
    try {
      _fn = new Function('data', 'validateFn', 'isUpdate', 'callback', _s);
    }
    catch (err) {
      throw new Error('Lunaris.validate: Impossible to compile the JSON validator.\n'+err+'\n--------------------------------\n'+_s+'\n--------------------------------\n');
    }
    return _fn;
  },

  /*
   *
   */
  getConditionCode : function (varName, params) {
    var _test         = '';
    var _type         = '';
    var _errorMessage = '';
    var _formatStr    = '';
    var _fnList       = [];

    // Check that we receive an array
    if (!(params instanceof Array)) {
      throw new Error('Lunaris.validate: the descriptor is invalid for the variable '+varName+'. You must use an array [] instead of '+JSON.stringify(params));
    }
    // store the first argument which is the type
    if (params.length!==0) {
      _type = params[0];
      if (inlineTest[_type]) {
        _test         = inlineTest[_type].getTest(varName);
        _errorMessage = inlineTest[_type]['error'];
      }
      else {
        throw new Error('Lunaris.validate: Unknown descriptor type "'+_type+'" in '+varName+':'+JSON.stringify(params));
      }
    }
    else {
      return {};
    }

    // anaylze other descriptor params
    var i = 1;
    while (i < params.length) {
      var _argument = params[i++];
      switch (_argument) {
        case 'min':
          var _value = params[i++];
          if (_type === 'int' || _type === 'number') {
            _test         += ' && '+varName+'>='+_value;
            _errorMessage += ' ${and must be superior or equal to} ' + _value;
          }
          else if (_type === 'numeric') {
            _test         += ' && parseInt('+varName+')>='+_value;
            _errorMessage += ' ${and must be superior or equal to} ' + _value;
          }
          else if (_type === 'decimal') {
            _test         += ' && parseFloat('+varName+')>='+_value;
            _errorMessage += ' ${and must be superior or equal to} ' + _value;
          }
          else if (_type === 'string' || _type === 'alpha' || _type === 'alphanumeric' || _type === 'array') {
            _test         += ' && '+varName+'.length>='+_value;
            _errorMessage += ' ${and the length must be superior or equal to} ' + _value;
          }
          break;
        case 'max':
          _value = params[i++];
          if (_type === 'int' || _type === 'number') {
            _test         += ' && '+varName+'<='+_value;
            _errorMessage += ' ${and must be inferior or equal to} ' + _value;
          }
          else if (_type === 'numeric') {
            _test         += ' && parseInt('+varName+')<='+_value;
            _errorMessage += ' ${and must be inferior or equal to} ' + _value;
          }
          else if (_type === 'decimal') {
            _test         += ' && parseFloat('+varName+')<='+_value;
            _errorMessage += ' ${and must be inferior or equal to} ' + _value;
          }
          else if (_type === 'string' || _type === 'alpha' || _type === 'alphanumeric' || _type === 'array') {
            _test         += ' && '+varName+'.length<='+_value;
            _errorMessage += ' ${and the length must be inferior or equal to} ' + _value;
          }
          break;
        case 'toBoolean':
          if (_type === 'binary') {
            _formatStr += varName+'= ('+varName+' === true || '+varName+' === "true" || '+varName+' === "1" || '+varName+' === 1) ? true:false; ';
          }
          break;
        case 'toInt':
          if (_type === 'numeric') {
            _formatStr += varName+'= parseInt('+varName+');';
          }
          break;
        case 'toNumber':
          if (_type === 'decimal') {
            _formatStr += varName+'= parseFloat('+varName+');';
          }
          break;
        case 'optional' :
          _test += ' || (' + varName + ' === null || ' + varName + ' === undefined || ' + varName + ' === \'\')';
          break;
        default:
          if (typeof _argument === 'function') {
            _fnList.push(_argument);
          }
          // throw new Error('Lunaris.validate: Unknown descriptor parameter "'+_argument+'" in '+varName+':'+JSON.stringify(params));
          break;
      }
    }

    var _res = {
      testStr      : _test,
      errorMessage : _errorMessage
    };

    // TODO refactor
    if (_formatStr) {
      _res.formatStr = _formatStr;
    }

    if (_fnList.length > 0) {
      _res.nbFunctions = _fnList.length;
    }

    return _res;
  }

};

module.exports = validate;
